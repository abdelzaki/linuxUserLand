94

- OS:
	- it consist of kernel and other softwares.

- kernel:
	- manage ressources 
	- manage RAM, CPU, access to device
	
- file descriptor:
	- it refers to an open file.
	- it is an integer number 
	- process inheriates three file descriptor std input. std outout, std error which are normally connected to shell

- process:
	- creation:
		- u create new process using fork system call which will create exactly the same process like the parent by calling dup system call.
		- the new process can call exec() to load a new process instead of the duplicated process
	
	- termination:
		- the process can be terminated by two ways:
			- the process itself can call exit() system call and can pass a value which can read from the parent process by calling wait()
			
			- being killed by signal from another process

- deaemon:
	- it is a normal process which runs in the background
	- because it runs in the background it has no controlling terminal
	

- IPC:
	
	- signals:
		- it is called software interrupt 
		- kill command can be used to send a signal to another process
		- u can define a signal handler to deal with a signal 
		
		


- system call:
	- entry point to the kernel
	- it changes the cpu from userland to the kernel land 
	- if there is an error the errno variable would be updated by the library 
	
	
- glibc:
	- it is the standard lbrary in linux it is GNU lib c
	- if u want to know which lib c u have u can call /lib/libc.so.6 
	
- I/O operations:
	- open system call:
		- it open a file or create a new file
		- int open(const char *pathname, int flags, ... /* mode_t mode */);
			-  if open is used to create a new file then the mode would decide the permission on this file,
			if open doesnot create a new file then the permission might be neglected. access mode are ex:
			S_IWUSR, S_IRUSR
			
		- if u valled open twice u would get a new file descriptor which does not share the offset with the first file
		
		- using dup() system call u get new file descriptor which point to the old file descriptor
		- dup(1,2) -> now one would refer to two 2<&1
		- to create a temp file u can use FILE *tmfile(void) and u can read and write to that file and it would delelted once u call close on the file
			- ex:
			- FILE *fp;
			- fp = tmpfile();
		
- Process:
	- each process has process ID
	- to send a signal to a process u can use kill()
	- to get the PID of a process u can use getpid()
	- the process uses virtuel memory 
	- kernel has page table for each process, page table maps the virtual memory to physical memory
	- 
	
- time:
	- real time : consist of two times
		- calender time: since fixed time point which is 1970 EPOC time
		- wall time: since the start of the process
	- cpu time: 
		- the time each process occupy from the cpu
		
	broken down time: it is the number of seconds but converted to year, month and hour, etc
		struct tm { int tm_sec; /* Seconds (0-60) */ int tm_min; , etc};
			
	
	- Time API:	
		- int gettimeofday(struct timeval *tv, struct timezone *tz)
			- return the second siche 1970 "tv->time_t" would have the seconds value
			
		- time_t time(time_t *timep);
			- return the time which is the number of seconds since 1970, u give null to the function
			
		- char *ctime(const time_t *timep)
			- would return fixed-format string ex: "Wed Jun 8 14:22:34 2011"
	
		- struct tm *gmtime(const time_t *timep)
		- struct tm *localtime(const time_t *timep)
			- would cinvert calender time to broken down format
			- local time would consider the time zone
			
		- time_t mktime(struct tm *timeptr)
			- would change tm toke number of seconds
	
	- in the directory usr/share/zoneinfo would be files for information about different time zones, the information about the local time would be in /etc/localtime which is linked to a file in "/usr/share/zoneinfo"
			
- Signals:
	- it is described as software interrupt
	- we use sysmbolic name of the signal as the number of the signal changes from platform to another platform
	- signals are divided to standard signals and real time signals.
	- to send a signal use kill command: int kill(pid_t pid, int sig);
		- pid > 0: it is sent to a normal process
		-  pid < 0 : each process which has PID less than this number
		- by sending sig = 0, u can check if the process can be signaled
	- standard signals have the value from 1 to 31 
		- SIGKILL : that is the sure kill signal u cannot create a handle to it, kill -9 , or kill -KILL
		- SIGTERM : that is the standard signal to terminate a process, it is send by kill or killall,

- Threads:
	- it has some data types:
		- pthread_t : Thread identifer
		- pthread_mutex_t: Mutex
		- pthread_cond_t: Condition variable
		- pthread_once_t: one time initialization
	
	- each thread has errno 
	- all programs which use Pthreads API must be compiled with cc -pthread option the program is linked with -lpthread
	
- Thread creation:
	- int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start)(void *), void *arg);
		- pthread_t is a buffer which can be used to store identifer of the thread which it is used later to identify the thread
		- 
- Thread Termination:
	- thread would be terminated using one of the options:
		- pthread_exit, pthread_cancel, exit
	
	- pthread_exit(void*):
		- it would terminate the thread and specifiy a return value which can be otained by another thread using pthread_join()
		- it is can be called by any function not only the main function as the case by return
		- the argument passed to the function should not be in the stack as the stack won't be avaliable 
		- if the main thread called pthread_exit(): other thread would remain exists
		
- join a thread:
	- int pthread_join(pthread_t thread, void **retval);
	- it is used when the thread is not detached
	- threads are paired in thread in a process can join with any other threads, it should not be parent child relationship
	- u should say which thread u want to join with u cannot say join with anythread as in the case of wait system call
	- retval: u give the address of void pointer
	
- detach:
	- int pthread_detach(pthread_t thread);
	- if u do want to make the thread joinable u can detach the thread
	- a thread can detach itself calling : pthread_detach(pthread_self());
	
- thread attributes:
	- u can supply attribute to the thread before creation using arrtribute parameter such as deciding that the pthread is detachable
	- ex:
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
		pthread_create(&thr, &attr, threadFunc, (void *) 1);
		
- thread synchronization:
	- Mutex:
		- it is used to synchronize the communication between threads
		- the variable is of type pthread_mutex_t
		- it should be initialized before using it 
			pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
			int pthread_mutex_lock(pthread_mutex_t *mutex);
			int pthread_mutex_unlock(pthread_mutex_t *mutex);
			
			to inialize mutex dynamically allocated
			int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
			int pthread_mutex_destroy(pthread_mutex_t *mutex);
			
		