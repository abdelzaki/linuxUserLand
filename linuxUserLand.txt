94

- OS:
	- it consist of kernel and other softwares.

- kernel:
	- manage ressources 
	- manage RAM, CPU, access to device
	
- file descriptor:
	- it refers to an open file.
	- it is an integer number 
	- process inheriates three file descriptor std input. std outout, std error which are normally connected to shell

- process:
	- creation:
		- u create new process using fork system call which will create exactly the same process like the parent by calling dup system call.
		- the new process can call exec() to load a new process instead of the duplicated process
	
	- termination:
		- the process can be terminated by two ways:
			- the process itself can call exit() system call and can pass a value which can read from the parent process by calling wait()
			
			- being killed by signal from another process

- deaemon:
	- it is a normal process which runs in the background
	- because it runs in the background it has no controlling terminal
	

- IPC:
	
	- signals:
		- it is called software interrupt 
		- kill command can be used to send a signal to another process
		- u can define a signal handler to deal with a signal 
		
		


- system call:
	- entry point to the kernel
	- it changes the cpu from userland to the kernel land 
	- if there is an error the errno variable would be updated by the library 
	
	
- glibc:
	- it is the standard lbrary in linux it is GNU lib c
	- if u want to know which lib c u have u can call /lib/libc.so.6 
	
- I/O operations:
	- open system call:
		- it open a file or create a new file
		- int open(const char *pathname, int flags, ... /* mode_t mode */);
			-  if open is used to create a new file then the mode would decide the permission on this file,
			if open doesnot create a new file then the permission might be neglected. access mode are ex:
			S_IWUSR, S_IRUSR
			
		- if u valled open twice u would get a new file descriptor which does not share the offset with the first file
		
		- using dup() system call u get new file descriptor which point to the old file descriptor
		- dup(1,2) -> now one would refer to two 2<&1
		- to create a temp file u can use FILE *tmfile(void) and u can read and write to that file and it would delelted once u call close on the file
			- ex:
			- FILE *fp;
			- fp = tmpfile();
		
- Process:
	- each process has process ID
	- to send a signal to a process u can use kill()
	- to get the PID of a process u can use getpid()
	- the process uses virtuel memory 
	- kernel has page table for each process, page table maps the virtual memory to physical memory
	- 
	
- time:
	- real time : consist of two times
		- calender time: since fixed time point which is 1970 EPOC time
		- wall time: since the start of the process
	- cpu time: 
		- the time each process occupy from the cpu
		
	broken down time: it is the number of seconds but converted to year, month and hour, etc
		struct tm { int tm_sec; /* Seconds (0-60) */ int tm_min; , etc};
			
	
	
	
	- Time API:	
		- int gettimeofday(struct timeval *tv, struct timezone *tz)
			- return the second siche 1970 "tv->time_t" would have the seconds value
			
		- time_t time(time_t *timep);
			- return the time which is the number of seconds since 1970, u give null to the function
			
		- char *ctime(const time_t *timep)
			- would return fixed-format string ex: "Wed Jun 8 14:22:34 2011"
	
		- struct tm *gmtime(const time_t *timep)
		- struct tm *localtime(const time_t *timep)
			- would cinvert calender time to broken down format
			- local time would consider the time zone
			
		- time_t mktime(struct tm *timeptr)
			- would change tm toke number of seconds
	
	- in the directory usr/share/zoneinfo would be files for information about different time zones, the information about the local time would be in /etc/localtime which is linked to a file in "/usr/share/zoneinfo"
			
- file system:
	- logical block consists of contigous pgysical blocks in disk driver
	- partition consists of super block which describe the file system in this partition and then i-node table which descrbe the data blocks and then the data blocks
	
	- if u want to know the mounted file uses mount command which would show the whole mounts file systems

	- to create soft link call: symlink(source, link) : the link should not exist before the call of symlink
	
			
			
			
			
		